import { BaseClass } from "./BaseClass";
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AudioFileClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getAudioFiles(companyId: string | undefined): Promise<AudioFileUI[]> {
        let url_ = this.baseUrl + "/api/AudioFile/GetAudioFiles?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAudioFiles(_response);
        });
    }

    protected processGetAudioFiles(response: Response): Promise<AudioFileUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AudioFileUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AudioFileUI[]>(null as any);
    }

    getGlobalAudioFiles(): Promise<AudioFileUI[]> {
        let url_ = this.baseUrl + "/api/AudioFile/GetGlobalAudioFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGlobalAudioFiles(_response);
        });
    }

    protected processGetGlobalAudioFiles(response: Response): Promise<AudioFileUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AudioFileUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AudioFileUI[]>(null as any);
    }

    getAudioFileById(audioFileId: string | undefined): Promise<AudioFileUI> {
        let url_ = this.baseUrl + "/api/AudioFile/GetAudioFileById?";
        if (audioFileId === null)
            throw new Error("The parameter 'audioFileId' cannot be null.");
        else if (audioFileId !== undefined)
            url_ += "audioFileId=" + encodeURIComponent("" + audioFileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAudioFileById(_response);
        });
    }

    protected processGetAudioFileById(response: Response): Promise<AudioFileUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AudioFileUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AudioFileUI>(null as any);
    }

    updateAudioFile(audioFileId: string | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/AudioFile/UpdateAudioFile?";
        if (audioFileId === null)
            throw new Error("The parameter 'audioFileId' cannot be null.");
        else if (audioFileId !== undefined)
            url_ += "audioFileId=" + encodeURIComponent("" + audioFileId) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateAudioFile(_response);
        });
    }

    protected processUpdateAudioFile(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    makeAudioFileGlobal(audioFileId: string | undefined, action: boolean | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/AudioFile/MakeAudioFileGlobal?";
        if (audioFileId === null)
            throw new Error("The parameter 'audioFileId' cannot be null.");
        else if (audioFileId !== undefined)
            url_ += "audioFileId=" + encodeURIComponent("" + audioFileId) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMakeAudioFileGlobal(_response);
        });
    }

    protected processMakeAudioFileGlobal(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    addToMyLibrary(companyId: string | undefined, globalAudioFileId: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/AudioFile/AddToMyLibrary?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (globalAudioFileId === null)
            throw new Error("The parameter 'globalAudioFileId' cannot be null.");
        else if (globalAudioFileId !== undefined)
            url_ += "globalAudioFileId=" + encodeURIComponent("" + globalAudioFileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddToMyLibrary(_response);
        });
    }

    protected processAddToMyLibrary(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CallUsingMyPhoneClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    setTargetCaller(fromPhoneNumber: string | null | undefined, toPhoneNumber: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/CallUsingMyPhone/SetTargetCaller?";
        if (fromPhoneNumber !== undefined && fromPhoneNumber !== null)
            url_ += "fromPhoneNumber=" + encodeURIComponent("" + fromPhoneNumber) + "&";
        if (toPhoneNumber !== undefined && toPhoneNumber !== null)
            url_ += "toPhoneNumber=" + encodeURIComponent("" + toPhoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetTargetCaller(_response);
        });
    }

    protected processSetTargetCaller(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    test(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/CallUsingMyPhone/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CDRClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getCDRRecords(companyId: string | undefined, startDate: Date | undefined): Promise<CDRRecordUI[]> {
        let url_ = this.baseUrl + "/api/CDR/GetCDRRecords?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCDRRecords(_response);
        });
    }

    protected processGetCDRRecords(response: Response): Promise<CDRRecordUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CDRRecordUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CDRRecordUI[]>(null as any);
    }
}

export class CompanyClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getCompanies(): Promise<CompanyUI[]> {
        let url_ = this.baseUrl + "/api/Company/GetCompanies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCompanies(_response);
        });
    }

    protected processGetCompanies(response: Response): Promise<CompanyUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyUI[]>(null as any);
    }

    getCompanyId(): Promise<string> {
        let url_ = this.baseUrl + "/api/Company/GetCompanyId";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCompanyId(_response);
        });
    }

    protected processGetCompanyId(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class ExtensionClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getExtensions(companyId: string | undefined): Promise<ExtensionUI[]> {
        let url_ = this.baseUrl + "/api/Extension/GetExtensions?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetExtensions(_response);
        });
    }

    protected processGetExtensions(response: Response): Promise<ExtensionUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExtensionUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtensionUI[]>(null as any);
    }

    getExtensionById(extensionId: string | undefined): Promise<ExtensionUI> {
        let url_ = this.baseUrl + "/api/Extension/GetExtensionById?";
        if (extensionId === null)
            throw new Error("The parameter 'extensionId' cannot be null.");
        else if (extensionId !== undefined)
            url_ += "extensionId=" + encodeURIComponent("" + extensionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetExtensionById(_response);
        });
    }

    protected processGetExtensionById(response: Response): Promise<ExtensionUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExtensionUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExtensionUI>(null as any);
    }

    addExtension(companyId: string | undefined, name: string | null | undefined, type: string | null | undefined, address: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Extension/AddExtension?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (address !== undefined && address !== null)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddExtension(_response);
        });
    }

    protected processAddExtension(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    updateExtension(extensionId: string | undefined, name: string | null | undefined, type: string | null | undefined, address: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Extension/UpdateExtension?";
        if (extensionId === null)
            throw new Error("The parameter 'extensionId' cannot be null.");
        else if (extensionId !== undefined)
            url_ += "extensionId=" + encodeURIComponent("" + extensionId) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (address !== undefined && address !== null)
            url_ += "address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateExtension(_response);
        });
    }

    protected processUpdateExtension(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class HolidayClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    addHoliday(phoneNumberId: string | undefined, holidayName: string | null | undefined, holidayDateFrom: Date | undefined, holidayDateTo: Date | undefined, isBusinessClosed: boolean | undefined, isCustomAudio: boolean | undefined, audioFileId: string | null | undefined): Promise<Holiday> {
        let url_ = this.baseUrl + "/api/Holiday/AddHoliday?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (holidayName !== undefined && holidayName !== null)
            url_ += "holidayName=" + encodeURIComponent("" + holidayName) + "&";
        if (holidayDateFrom === null)
            throw new Error("The parameter 'holidayDateFrom' cannot be null.");
        else if (holidayDateFrom !== undefined)
            url_ += "holidayDateFrom=" + encodeURIComponent(holidayDateFrom ? "" + holidayDateFrom.toISOString() : "") + "&";
        if (holidayDateTo === null)
            throw new Error("The parameter 'holidayDateTo' cannot be null.");
        else if (holidayDateTo !== undefined)
            url_ += "holidayDateTo=" + encodeURIComponent(holidayDateTo ? "" + holidayDateTo.toISOString() : "") + "&";
        if (isBusinessClosed === null)
            throw new Error("The parameter 'isBusinessClosed' cannot be null.");
        else if (isBusinessClosed !== undefined)
            url_ += "isBusinessClosed=" + encodeURIComponent("" + isBusinessClosed) + "&";
        if (isCustomAudio === null)
            throw new Error("The parameter 'isCustomAudio' cannot be null.");
        else if (isCustomAudio !== undefined)
            url_ += "isCustomAudio=" + encodeURIComponent("" + isCustomAudio) + "&";
        if (audioFileId !== undefined && audioFileId !== null)
            url_ += "audioFileId=" + encodeURIComponent("" + audioFileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddHoliday(_response);
        });
    }

    protected processAddHoliday(response: Response): Promise<Holiday> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Holiday.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Holiday>(null as any);
    }

    getHolidays(phoneNumberId: string | undefined): Promise<Holiday[]> {
        let url_ = this.baseUrl + "/api/Holiday/GetHolidays?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHolidays(_response);
        });
    }

    protected processGetHolidays(response: Response): Promise<Holiday[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Holiday.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Holiday[]>(null as any);
    }

    getGlobalHolidays(): Promise<Holiday[]> {
        let url_ = this.baseUrl + "/api/Holiday/GetGlobalHolidays";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGlobalHolidays(_response);
        });
    }

    protected processGetGlobalHolidays(response: Response): Promise<Holiday[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Holiday.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Holiday[]>(null as any);
    }

    getGlobalHolidaysByPhoneNumber(phoneNumberId: string | undefined): Promise<HolidayUI[]> {
        let url_ = this.baseUrl + "/api/Holiday/GetGlobalHolidaysByPhoneNumber?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGlobalHolidaysByPhoneNumber(_response);
        });
    }

    protected processGetGlobalHolidaysByPhoneNumber(response: Response): Promise<HolidayUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HolidayUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HolidayUI[]>(null as any);
    }

    subscribeToHoliday(phoneNumberId: string | undefined, holidayId: string | undefined): Promise<HolidayUI[]> {
        let url_ = this.baseUrl + "/api/Holiday/SubscribeToHoliday?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (holidayId === null)
            throw new Error("The parameter 'holidayId' cannot be null.");
        else if (holidayId !== undefined)
            url_ += "holidayId=" + encodeURIComponent("" + holidayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSubscribeToHoliday(_response);
        });
    }

    protected processSubscribeToHoliday(response: Response): Promise<HolidayUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HolidayUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HolidayUI[]>(null as any);
    }

    unsubscribeFromHoliday(phoneNumberId: string | undefined, holidayId: string | undefined): Promise<HolidayUI[]> {
        let url_ = this.baseUrl + "/api/Holiday/UnsubscribeFromHoliday?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (holidayId === null)
            throw new Error("The parameter 'holidayId' cannot be null.");
        else if (holidayId !== undefined)
            url_ += "holidayId=" + encodeURIComponent("" + holidayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnsubscribeFromHoliday(_response);
        });
    }

    protected processUnsubscribeFromHoliday(response: Response): Promise<HolidayUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HolidayUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HolidayUI[]>(null as any);
    }

    optInHoliday(globalHolidayId: string | undefined, targetPhoneNumberId: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Holiday/OptInHoliday?";
        if (globalHolidayId === null)
            throw new Error("The parameter 'globalHolidayId' cannot be null.");
        else if (globalHolidayId !== undefined)
            url_ += "globalHolidayId=" + encodeURIComponent("" + globalHolidayId) + "&";
        if (targetPhoneNumberId === null)
            throw new Error("The parameter 'targetPhoneNumberId' cannot be null.");
        else if (targetPhoneNumberId !== undefined)
            url_ += "targetPhoneNumberId=" + encodeURIComponent("" + targetPhoneNumberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processOptInHoliday(_response);
        });
    }

    protected processOptInHoliday(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    deleteHoliday(holidayId: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Holiday/DeleteHoliday?";
        if (holidayId === null)
            throw new Error("The parameter 'holidayId' cannot be null.");
        else if (holidayId !== undefined)
            url_ += "holidayId=" + encodeURIComponent("" + holidayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteHoliday(_response);
        });
    }

    protected processDeleteHoliday(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class MediaClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getMedia(name: string | null | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Media/GetMedia?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMedia(_response);
        });
    }

    protected processGetMedia(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }
}

export class MenuClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getMenus(companyId: string | undefined): Promise<MenuUI[]> {
        let url_ = this.baseUrl + "/api/Menu/GetMenus?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMenus(_response);
        });
    }

    protected processGetMenus(response: Response): Promise<MenuUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuUI[]>(null as any);
    }

    getMenuById(menuId: string | undefined): Promise<MenuUI> {
        let url_ = this.baseUrl + "/api/Menu/GetMenuById?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMenuById(_response);
        });
    }

    protected processGetMenuById(response: Response): Promise<MenuUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuUI>(null as any);
    }

    updateMenu(menuId: string | undefined, name: string | null | undefined, description: string | null | undefined, timeOut: number | undefined, dtfAudioIds: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Menu/UpdateMenu?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        if (timeOut === null)
            throw new Error("The parameter 'timeOut' cannot be null.");
        else if (timeOut !== undefined)
            url_ += "timeOut=" + encodeURIComponent("" + timeOut) + "&";
        if (dtfAudioIds !== undefined && dtfAudioIds !== null)
            url_ += "dtfAudioIds=" + encodeURIComponent("" + dtfAudioIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMenu(_response);
        });
    }

    protected processUpdateMenu(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    updateMenuAction(menuId: string | undefined, configuration: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Menu/UpdateMenuAction?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&";
        if (configuration !== undefined && configuration !== null)
            url_ += "configuration=" + encodeURIComponent("" + configuration) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateMenuAction(_response);
        });
    }

    protected processUpdateMenuAction(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    addMenu(companyId: string | undefined, ui: MenuUI): Promise<string> {
        let url_ = this.baseUrl + "/api/Menu/AddMenu?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ui);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddMenu(_response);
        });
    }

    protected processAddMenu(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class MoneyTransactionClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    addInvoice(phoneNumberId: string | undefined, invoiceNumber: string | null | undefined, amount: number | undefined, serviceDateStart: Date | undefined, serviceDateEnd: Date | undefined, invoiceDate: Date | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/MoneyTransaction/AddInvoice?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (invoiceNumber !== undefined && invoiceNumber !== null)
            url_ += "invoiceNumber=" + encodeURIComponent("" + invoiceNumber) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (serviceDateStart === null)
            throw new Error("The parameter 'serviceDateStart' cannot be null.");
        else if (serviceDateStart !== undefined)
            url_ += "serviceDateStart=" + encodeURIComponent(serviceDateStart ? "" + serviceDateStart.toISOString() : "") + "&";
        if (serviceDateEnd === null)
            throw new Error("The parameter 'serviceDateEnd' cannot be null.");
        else if (serviceDateEnd !== undefined)
            url_ += "serviceDateEnd=" + encodeURIComponent(serviceDateEnd ? "" + serviceDateEnd.toISOString() : "") + "&";
        if (invoiceDate === null)
            throw new Error("The parameter 'invoiceDate' cannot be null.");
        else if (invoiceDate !== undefined)
            url_ += "invoiceDate=" + encodeURIComponent(invoiceDate ? "" + invoiceDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddInvoice(_response);
        });
    }

    protected processAddInvoice(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    addPayment(phoneNumberId: string | undefined, amount: number | undefined, paymentDate: Date | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/MoneyTransaction/AddPayment?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (amount === null)
            throw new Error("The parameter 'amount' cannot be null.");
        else if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        if (paymentDate === null)
            throw new Error("The parameter 'paymentDate' cannot be null.");
        else if (paymentDate !== undefined)
            url_ += "paymentDate=" + encodeURIComponent(paymentDate ? "" + paymentDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddPayment(_response);
        });
    }

    protected processAddPayment(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class PhoneNumberClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getPhoneNumberById(phoneNumberId: string | undefined): Promise<PhoneNumberUI> {
        let url_ = this.baseUrl + "/api/PhoneNumber/GetPhoneNumberById?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPhoneNumberById(_response);
        });
    }

    protected processGetPhoneNumberById(response: Response): Promise<PhoneNumberUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PhoneNumberUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhoneNumberUI>(null as any);
    }

    getPhoneNumbers(companyId: string | undefined): Promise<PhoneNumberUI[]> {
        let url_ = this.baseUrl + "/api/PhoneNumber/GetPhoneNumbers?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPhoneNumbers(_response);
        });
    }

    protected processGetPhoneNumbers(response: Response): Promise<PhoneNumberUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhoneNumberUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhoneNumberUI[]>(null as any);
    }

    getAllPhoneNumbersForUser(): Promise<PhoneNumberUI[]> {
        let url_ = this.baseUrl + "/api/PhoneNumber/GetAllPhoneNumbersForUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllPhoneNumbersForUser(_response);
        });
    }

    protected processGetAllPhoneNumbersForUser(response: Response): Promise<PhoneNumberUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhoneNumberUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PhoneNumberUI[]>(null as any);
    }

    addPhoneNumber(companyId: string | undefined, phoneNumberDigits: string | null | undefined, action: string | null | undefined, voicemailAudioId: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/PhoneNumber/AddPhoneNumber?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (phoneNumberDigits !== undefined && phoneNumberDigits !== null)
            url_ += "phoneNumberDigits=" + encodeURIComponent("" + phoneNumberDigits) + "&";
        if (action !== undefined && action !== null)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (voicemailAudioId !== undefined && voicemailAudioId !== null)
            url_ += "voicemailAudioId=" + encodeURIComponent("" + voicemailAudioId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddPhoneNumber(_response);
        });
    }

    protected processAddPhoneNumber(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    updatePhoneNumber(phoneNumberId: string | undefined, phoneNumberUI: PhoneNumberUI): Promise<boolean> {
        let url_ = this.baseUrl + "/api/PhoneNumber/UpdatePhoneNumber?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(phoneNumberUI);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePhoneNumber(_response);
        });
    }

    protected processUpdatePhoneNumber(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    updateBusinessHours(phoneNumberId: string | undefined, businessHours: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/PhoneNumber/UpdateBusinessHours?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (businessHours !== undefined && businessHours !== null)
            url_ += "businessHours=" + encodeURIComponent("" + businessHours) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateBusinessHours(_response);
        });
    }

    protected processUpdateBusinessHours(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    updateHolidays(phoneNumberId: string | undefined, holidays: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/PhoneNumber/UpdateHolidays?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (holidays !== undefined && holidays !== null)
            url_ += "holidays=" + encodeURIComponent("" + holidays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateHolidays(_response);
        });
    }

    protected processUpdateHolidays(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class RecordingClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getVoiceMails(companyId: string | undefined): Promise<Recording[]> {
        let url_ = this.baseUrl + "/api/Recording/GetVoiceMails?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVoiceMails(_response);
        });
    }

    protected processGetVoiceMails(response: Response): Promise<Recording[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Recording.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Recording[]>(null as any);
    }

    getVoiceMailsByPhoneNumberId(phoneNumberId: string | undefined): Promise<Recording[]> {
        let url_ = this.baseUrl + "/api/Recording/GetVoiceMailsByPhoneNumberId?";
        if (phoneNumberId === null)
            throw new Error("The parameter 'phoneNumberId' cannot be null.");
        else if (phoneNumberId !== undefined)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetVoiceMailsByPhoneNumberId(_response);
        });
    }

    protected processGetVoiceMailsByPhoneNumberId(response: Response): Promise<Recording[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Recording.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Recording[]>(null as any);
    }

    deleteVoicemail(recordingId: string | undefined): Promise<Recording> {
        let url_ = this.baseUrl + "/api/Recording/DeleteVoicemail?";
        if (recordingId === null)
            throw new Error("The parameter 'recordingId' cannot be null.");
        else if (recordingId !== undefined)
            url_ += "recordingId=" + encodeURIComponent("" + recordingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteVoicemail(_response);
        });
    }

    protected processDeleteVoicemail(response: Response): Promise<Recording> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Recording.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Recording>(null as any);
    }
}

export class RuleClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    getRuleById(ruleId: string | undefined): Promise<RuleUI> {
        let url_ = this.baseUrl + "/api/Rule/GetRuleById?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "RuleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRuleById(_response);
        });
    }

    protected processGetRuleById(response: Response): Promise<RuleUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RuleUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuleUI>(null as any);
    }

    getRules(companyId: string | undefined): Promise<RuleUI[]> {
        let url_ = this.baseUrl + "/api/Rule/GetRules?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRules(_response);
        });
    }

    protected processGetRules(response: Response): Promise<RuleUI[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RuleUI.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuleUI[]>(null as any);
    }

    updateRuleItems(ruleId: string | undefined, ruleUI: RuleUI): Promise<RuleUI> {
        let url_ = this.baseUrl + "/api/Rule/UpdateRuleItems?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ruleUI);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateRuleItems(_response);
        });
    }

    protected processUpdateRuleItems(response: Response): Promise<RuleUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RuleUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuleUI>(null as any);
    }

    updateRule(ruleId: string | undefined, ruleUI: RuleUI): Promise<RuleUI> {
        let url_ = this.baseUrl + "/api/Rule/UpdateRule?";
        if (ruleId === null)
            throw new Error("The parameter 'ruleId' cannot be null.");
        else if (ruleId !== undefined)
            url_ += "ruleId=" + encodeURIComponent("" + ruleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ruleUI);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateRule(_response);
        });
    }

    protected processUpdateRule(response: Response): Promise<RuleUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RuleUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuleUI>(null as any);
    }

    addRule(companyId: string | undefined, ruleName: string | null | undefined): Promise<RuleUI> {
        let url_ = this.baseUrl + "/api/Rule/AddRule?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (ruleName !== undefined && ruleName !== null)
            url_ += "ruleName=" + encodeURIComponent("" + ruleName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddRule(_response);
        });
    }

    protected processAddRule(response: Response): Promise<RuleUI> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RuleUI.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RuleUI>(null as any);
    }
}

export class SMSOutgoingClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    outgoingMessage(phoneNumberId: string | null | undefined, customerPhoneNumber: string | null | undefined, messageText: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/SMSOutgoing/OutgoingMessage?";
        if (phoneNumberId !== undefined && phoneNumberId !== null)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (customerPhoneNumber !== undefined && customerPhoneNumber !== null)
            url_ += "customerPhoneNumber=" + encodeURIComponent("" + customerPhoneNumber) + "&";
        if (messageText !== undefined && messageText !== null)
            url_ += "messageText=" + encodeURIComponent("" + messageText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processOutgoingMessage(_response);
        });
    }

    protected processOutgoingMessage(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    createNewChat(phoneNumberId: string | null | undefined, customerPhoneNumber: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/SMSOutgoing/CreateNewChat?";
        if (phoneNumberId !== undefined && phoneNumberId !== null)
            url_ += "phoneNumberId=" + encodeURIComponent("" + phoneNumberId) + "&";
        if (customerPhoneNumber !== undefined && customerPhoneNumber !== null)
            url_ += "customerPhoneNumber=" + encodeURIComponent("" + customerPhoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateNewChat(_response);
        });
    }

    protected processCreateNewChat(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class TextToAudioClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    updateTextToAudio(audioFileId: string | undefined, audioFileUI: AudioFileUI, languageModel: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/TextToAudio/UpdateTextToAudio?";
        if (audioFileId === null)
            throw new Error("The parameter 'audioFileId' cannot be null.");
        else if (audioFileId !== undefined)
            url_ += "audioFileId=" + encodeURIComponent("" + audioFileId) + "&";
        if (languageModel !== undefined && languageModel !== null)
            url_ += "languageModel=" + encodeURIComponent("" + languageModel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(audioFileUI);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTextToAudio(_response);
        });
    }

    protected processUpdateTextToAudio(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    convertTextToAudio(companyId: string | undefined, audioFileUI: AudioFileUI, languageModel: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/TextToAudio/ConvertTextToAudio?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (languageModel !== undefined && languageModel !== null)
            url_ += "languageModel=" + encodeURIComponent("" + languageModel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(audioFileUI);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConvertTextToAudio(_response);
        });
    }

    protected processConvertTextToAudio(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class UploadClient extends BaseClass {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }, bearerToken?: string) {
        super(bearerToken);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44369";
    }

    uploadFile(companyId: string | undefined, updateAudioFile: boolean | undefined, audioFileId: string | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/Upload?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (updateAudioFile === null)
            throw new Error("The parameter 'updateAudioFile' cannot be null.");
        else if (updateAudioFile !== undefined)
            url_ += "updateAudioFile=" + encodeURIComponent("" + updateAudioFile) + "&";
        if (audioFileId === null)
            throw new Error("The parameter 'audioFileId' cannot be null.");
        else if (audioFileId !== undefined)
            url_ += "audioFileId=" + encodeURIComponent("" + audioFileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class AudioFileUI implements IAudioFileUI {
    audioFileId!: string;
    name?: string | undefined;
    textToConvert?: string | undefined;
    path?: string | undefined;
    fileSize?: number | undefined;
    isGlobal!: boolean;
    isUploadedToTelnyx!: boolean;

    constructor(data?: IAudioFileUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audioFileId = _data["audioFileId"];
            this.name = _data["name"];
            this.textToConvert = _data["textToConvert"];
            this.path = _data["path"];
            this.fileSize = _data["fileSize"];
            this.isGlobal = _data["isGlobal"];
            this.isUploadedToTelnyx = _data["isUploadedToTelnyx"];
        }
    }

    static fromJS(data: any): AudioFileUI {
        data = typeof data === 'object' ? data : {};
        let result = new AudioFileUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audioFileId"] = this.audioFileId;
        data["name"] = this.name;
        data["textToConvert"] = this.textToConvert;
        data["path"] = this.path;
        data["fileSize"] = this.fileSize;
        data["isGlobal"] = this.isGlobal;
        data["isUploadedToTelnyx"] = this.isUploadedToTelnyx;
        return data;
    }
}

export interface IAudioFileUI {
    audioFileId: string;
    name?: string | undefined;
    textToConvert?: string | undefined;
    path?: string | undefined;
    fileSize?: number | undefined;
    isGlobal: boolean;
    isUploadedToTelnyx: boolean;
}

export class CDRRecordUI implements ICDRRecordUI {
    originatingNumber?: string | undefined;
    terminatingnumber?: string | undefined;
    startTimestamp!: Date;
    endTimestamp!: Date;
    direction?: string | undefined;

    constructor(data?: ICDRRecordUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originatingNumber = _data["originatingNumber"];
            this.terminatingnumber = _data["terminatingnumber"];
            this.startTimestamp = _data["startTimestamp"] ? new Date(_data["startTimestamp"].toString()) : <any>undefined;
            this.endTimestamp = _data["endTimestamp"] ? new Date(_data["endTimestamp"].toString()) : <any>undefined;
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): CDRRecordUI {
        data = typeof data === 'object' ? data : {};
        let result = new CDRRecordUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originatingNumber"] = this.originatingNumber;
        data["terminatingnumber"] = this.terminatingnumber;
        data["startTimestamp"] = this.startTimestamp ? this.startTimestamp.toISOString() : <any>undefined;
        data["endTimestamp"] = this.endTimestamp ? this.endTimestamp.toISOString() : <any>undefined;
        data["direction"] = this.direction;
        return data;
    }
}

export interface ICDRRecordUI {
    originatingNumber?: string | undefined;
    terminatingnumber?: string | undefined;
    startTimestamp: Date;
    endTimestamp: Date;
    direction?: string | undefined;
}

export class CompanyUI implements ICompanyUI {
    companyId!: string;
    userId!: string;
    name?: string | undefined;

    constructor(data?: ICompanyUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CompanyUI {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICompanyUI {
    companyId: string;
    userId: string;
    name?: string | undefined;
}

export class ExtensionUI implements IExtensionUI {
    extensionId!: string;
    name?: string | undefined;
    extensionType?: string | undefined;
    address?: string | undefined;

    constructor(data?: IExtensionUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.extensionId = _data["extensionId"];
            this.name = _data["name"];
            this.extensionType = _data["extensionType"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): ExtensionUI {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extensionId"] = this.extensionId;
        data["name"] = this.name;
        data["extensionType"] = this.extensionType;
        data["address"] = this.address;
        return data;
    }
}

export interface IExtensionUI {
    extensionId: string;
    name?: string | undefined;
    extensionType?: string | undefined;
    address?: string | undefined;
}

export class Holiday implements IHoliday {
    holidayId!: string;
    phoneNumberId!: string;
    holidayName?: string | undefined;
    fromDate!: Date;
    toDate!: Date;
    isBusinessClosed!: boolean;
    isCustomAudio!: boolean;
    audioFileId?: string | undefined;
    audioFile?: AudioFile | undefined;
    phoneNumber?: PhoneNumber | undefined;
    holidaySubscriptions?: HolidaySubscription[] | undefined;

    constructor(data?: IHoliday) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holidayId = _data["holidayId"];
            this.phoneNumberId = _data["phoneNumberId"];
            this.holidayName = _data["holidayName"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.isBusinessClosed = _data["isBusinessClosed"];
            this.isCustomAudio = _data["isCustomAudio"];
            this.audioFileId = _data["audioFileId"];
            this.audioFile = _data["audioFile"] ? AudioFile.fromJS(_data["audioFile"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"] ? PhoneNumber.fromJS(_data["phoneNumber"]) : <any>undefined;
            if (Array.isArray(_data["holidaySubscriptions"])) {
                this.holidaySubscriptions = [] as any;
                for (let item of _data["holidaySubscriptions"])
                    this.holidaySubscriptions!.push(HolidaySubscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Holiday {
        data = typeof data === 'object' ? data : {};
        let result = new Holiday();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holidayId"] = this.holidayId;
        data["phoneNumberId"] = this.phoneNumberId;
        data["holidayName"] = this.holidayName;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["isBusinessClosed"] = this.isBusinessClosed;
        data["isCustomAudio"] = this.isCustomAudio;
        data["audioFileId"] = this.audioFileId;
        data["audioFile"] = this.audioFile ? this.audioFile.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>undefined;
        if (Array.isArray(this.holidaySubscriptions)) {
            data["holidaySubscriptions"] = [];
            for (let item of this.holidaySubscriptions)
                data["holidaySubscriptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHoliday {
    holidayId: string;
    phoneNumberId: string;
    holidayName?: string | undefined;
    fromDate: Date;
    toDate: Date;
    isBusinessClosed: boolean;
    isCustomAudio: boolean;
    audioFileId?: string | undefined;
    audioFile?: AudioFile | undefined;
    phoneNumber?: PhoneNumber | undefined;
    holidaySubscriptions?: HolidaySubscription[] | undefined;
}

export class AudioFile implements IAudioFile {
    audioFileId!: string;
    name?: string | undefined;
    textToConvert?: string | undefined;
    path?: string | undefined;
    companyId!: string;
    fileSize?: number | undefined;
    isGlobal!: boolean;
    isUploadedToTelnyx!: boolean;
    company?: Company | undefined;
    holidays?: Holiday[] | undefined;
    phoneNumbers?: PhoneNumber[] | undefined;

    constructor(data?: IAudioFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.audioFileId = _data["audioFileId"];
            this.name = _data["name"];
            this.textToConvert = _data["textToConvert"];
            this.path = _data["path"];
            this.companyId = _data["companyId"];
            this.fileSize = _data["fileSize"];
            this.isGlobal = _data["isGlobal"];
            this.isUploadedToTelnyx = _data["isUploadedToTelnyx"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            if (Array.isArray(_data["holidays"])) {
                this.holidays = [] as any;
                for (let item of _data["holidays"])
                    this.holidays!.push(Holiday.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(PhoneNumber.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AudioFile {
        data = typeof data === 'object' ? data : {};
        let result = new AudioFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audioFileId"] = this.audioFileId;
        data["name"] = this.name;
        data["textToConvert"] = this.textToConvert;
        data["path"] = this.path;
        data["companyId"] = this.companyId;
        data["fileSize"] = this.fileSize;
        data["isGlobal"] = this.isGlobal;
        data["isUploadedToTelnyx"] = this.isUploadedToTelnyx;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.holidays)) {
            data["holidays"] = [];
            for (let item of this.holidays)
                data["holidays"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAudioFile {
    audioFileId: string;
    name?: string | undefined;
    textToConvert?: string | undefined;
    path?: string | undefined;
    companyId: string;
    fileSize?: number | undefined;
    isGlobal: boolean;
    isUploadedToTelnyx: boolean;
    company?: Company | undefined;
    holidays?: Holiday[] | undefined;
    phoneNumbers?: PhoneNumber[] | undefined;
}

export class Company implements ICompany {
    companyId!: string;
    userId!: string;
    name?: string | undefined;
    user?: User | undefined;
    audioFiles?: AudioFile[] | undefined;
    extensions?: Extension[] | undefined;
    menus?: Menu[] | undefined;
    phoneNumbers?: PhoneNumber[] | undefined;
    rules?: Rule[] | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["audioFiles"])) {
                this.audioFiles = [] as any;
                for (let item of _data["audioFiles"])
                    this.audioFiles!.push(AudioFile.fromJS(item));
            }
            if (Array.isArray(_data["extensions"])) {
                this.extensions = [] as any;
                for (let item of _data["extensions"])
                    this.extensions!.push(Extension.fromJS(item));
            }
            if (Array.isArray(_data["menus"])) {
                this.menus = [] as any;
                for (let item of _data["menus"])
                    this.menus!.push(Menu.fromJS(item));
            }
            if (Array.isArray(_data["phoneNumbers"])) {
                this.phoneNumbers = [] as any;
                for (let item of _data["phoneNumbers"])
                    this.phoneNumbers!.push(PhoneNumber.fromJS(item));
            }
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(Rule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.audioFiles)) {
            data["audioFiles"] = [];
            for (let item of this.audioFiles)
                data["audioFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.extensions)) {
            data["extensions"] = [];
            for (let item of this.extensions)
                data["extensions"].push(item.toJSON());
        }
        if (Array.isArray(this.menus)) {
            data["menus"] = [];
            for (let item of this.menus)
                data["menus"].push(item.toJSON());
        }
        if (Array.isArray(this.phoneNumbers)) {
            data["phoneNumbers"] = [];
            for (let item of this.phoneNumbers)
                data["phoneNumbers"].push(item.toJSON());
        }
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICompany {
    companyId: string;
    userId: string;
    name?: string | undefined;
    user?: User | undefined;
    audioFiles?: AudioFile[] | undefined;
    extensions?: Extension[] | undefined;
    menus?: Menu[] | undefined;
    phoneNumbers?: PhoneNumber[] | undefined;
    rules?: Rule[] | undefined;
}

export class User implements IUser {
    userId!: string;
    emailAddress?: string | undefined;
    userName?: string | undefined;
    companies?: Company[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies!.push(Company.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    userId: string;
    emailAddress?: string | undefined;
    userName?: string | undefined;
    companies?: Company[] | undefined;
}

export class Extension implements IExtension {
    extensionId!: string;
    name?: string | undefined;
    extensionType?: string | undefined;
    address?: string | undefined;
    companyId!: string;
    company?: Company | undefined;

    constructor(data?: IExtension) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.extensionId = _data["extensionId"];
            this.name = _data["name"];
            this.extensionType = _data["extensionType"];
            this.address = _data["address"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Extension {
        data = typeof data === 'object' ? data : {};
        let result = new Extension();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extensionId"] = this.extensionId;
        data["name"] = this.name;
        data["extensionType"] = this.extensionType;
        data["address"] = this.address;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtension {
    extensionId: string;
    name?: string | undefined;
    extensionType?: string | undefined;
    address?: string | undefined;
    companyId: string;
    company?: Company | undefined;
}

export class Menu implements IMenu {
    menuId!: string;
    name?: string | undefined;
    companyId!: string;
    timeout!: number;
    configuration?: string | undefined;
    description?: string | undefined;
    dtfAudioIds?: string | undefined;
    company?: Company | undefined;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuId = _data["menuId"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.timeout = _data["timeout"];
            this.configuration = _data["configuration"];
            this.description = _data["description"];
            this.dtfAudioIds = _data["dtfAudioIds"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["timeout"] = this.timeout;
        data["configuration"] = this.configuration;
        data["description"] = this.description;
        data["dtfAudioIds"] = this.dtfAudioIds;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMenu {
    menuId: string;
    name?: string | undefined;
    companyId: string;
    timeout: number;
    configuration?: string | undefined;
    description?: string | undefined;
    dtfAudioIds?: string | undefined;
    company?: Company | undefined;
}

export class PhoneNumber implements IPhoneNumber {
    phoneNumberId!: string;
    companyId!: string;
    phoneNumberDigits?: string | undefined;
    action?: string | undefined;
    voicemailAudioId?: string | undefined;
    businessHours?: string | undefined;
    holidays?: string | undefined;
    timeZone?: string | undefined;
    voicemailEmail?: string | undefined;
    ringTimeout?: number | undefined;
    marketingMessages?: string | undefined;
    company?: Company | undefined;
    voicemailAudio?: AudioFile | undefined;
    holidaySubscriptions?: HolidaySubscription[] | undefined;
    holidaysNavigation?: Holiday[] | undefined;

    constructor(data?: IPhoneNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumberId = _data["phoneNumberId"];
            this.companyId = _data["companyId"];
            this.phoneNumberDigits = _data["phoneNumberDigits"];
            this.action = _data["action"];
            this.voicemailAudioId = _data["voicemailAudioId"];
            this.businessHours = _data["businessHours"];
            this.holidays = _data["holidays"];
            this.timeZone = _data["timeZone"];
            this.voicemailEmail = _data["voicemailEmail"];
            this.ringTimeout = _data["ringTimeout"];
            this.marketingMessages = _data["marketingMessages"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.voicemailAudio = _data["voicemailAudio"] ? AudioFile.fromJS(_data["voicemailAudio"]) : <any>undefined;
            if (Array.isArray(_data["holidaySubscriptions"])) {
                this.holidaySubscriptions = [] as any;
                for (let item of _data["holidaySubscriptions"])
                    this.holidaySubscriptions!.push(HolidaySubscription.fromJS(item));
            }
            if (Array.isArray(_data["holidaysNavigation"])) {
                this.holidaysNavigation = [] as any;
                for (let item of _data["holidaysNavigation"])
                    this.holidaysNavigation!.push(Holiday.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumberId"] = this.phoneNumberId;
        data["companyId"] = this.companyId;
        data["phoneNumberDigits"] = this.phoneNumberDigits;
        data["action"] = this.action;
        data["voicemailAudioId"] = this.voicemailAudioId;
        data["businessHours"] = this.businessHours;
        data["holidays"] = this.holidays;
        data["timeZone"] = this.timeZone;
        data["voicemailEmail"] = this.voicemailEmail;
        data["ringTimeout"] = this.ringTimeout;
        data["marketingMessages"] = this.marketingMessages;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["voicemailAudio"] = this.voicemailAudio ? this.voicemailAudio.toJSON() : <any>undefined;
        if (Array.isArray(this.holidaySubscriptions)) {
            data["holidaySubscriptions"] = [];
            for (let item of this.holidaySubscriptions)
                data["holidaySubscriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.holidaysNavigation)) {
            data["holidaysNavigation"] = [];
            for (let item of this.holidaysNavigation)
                data["holidaysNavigation"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPhoneNumber {
    phoneNumberId: string;
    companyId: string;
    phoneNumberDigits?: string | undefined;
    action?: string | undefined;
    voicemailAudioId?: string | undefined;
    businessHours?: string | undefined;
    holidays?: string | undefined;
    timeZone?: string | undefined;
    voicemailEmail?: string | undefined;
    ringTimeout?: number | undefined;
    marketingMessages?: string | undefined;
    company?: Company | undefined;
    voicemailAudio?: AudioFile | undefined;
    holidaySubscriptions?: HolidaySubscription[] | undefined;
    holidaysNavigation?: Holiday[] | undefined;
}

export class HolidaySubscription implements IHolidaySubscription {
    holidaySubscriptionId!: string;
    phoneNumberId!: string;
    holidayId!: string;
    holiday?: Holiday | undefined;
    phoneNumber?: PhoneNumber | undefined;

    constructor(data?: IHolidaySubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holidaySubscriptionId = _data["holidaySubscriptionId"];
            this.phoneNumberId = _data["phoneNumberId"];
            this.holidayId = _data["holidayId"];
            this.holiday = _data["holiday"] ? Holiday.fromJS(_data["holiday"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"] ? PhoneNumber.fromJS(_data["phoneNumber"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HolidaySubscription {
        data = typeof data === 'object' ? data : {};
        let result = new HolidaySubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holidaySubscriptionId"] = this.holidaySubscriptionId;
        data["phoneNumberId"] = this.phoneNumberId;
        data["holidayId"] = this.holidayId;
        data["holiday"] = this.holiday ? this.holiday.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHolidaySubscription {
    holidaySubscriptionId: string;
    phoneNumberId: string;
    holidayId: string;
    holiday?: Holiday | undefined;
    phoneNumber?: PhoneNumber | undefined;
}

export class Rule implements IRule {
    ruleId!: string;
    ruleName?: string | undefined;
    ruleItems?: string | undefined;
    companyId!: string;
    defaultRuleAction?: string | undefined;
    company?: Company | undefined;

    constructor(data?: IRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleId = _data["ruleId"];
            this.ruleName = _data["ruleName"];
            this.ruleItems = _data["ruleItems"];
            this.companyId = _data["companyId"];
            this.defaultRuleAction = _data["defaultRuleAction"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Rule {
        data = typeof data === 'object' ? data : {};
        let result = new Rule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        data["ruleItems"] = this.ruleItems;
        data["companyId"] = this.companyId;
        data["defaultRuleAction"] = this.defaultRuleAction;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRule {
    ruleId: string;
    ruleName?: string | undefined;
    ruleItems?: string | undefined;
    companyId: string;
    defaultRuleAction?: string | undefined;
    company?: Company | undefined;
}

export class HolidayUI implements IHolidayUI {
    holidayId!: string;
    isBusinessClosed!: boolean;
    audioFileUI?: AudioFileUI | undefined;
    fromDate!: Date;
    toDate!: Date;
    holidayName?: string | undefined;
    isSubscribed!: boolean;

    constructor(data?: IHolidayUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holidayId = _data["holidayId"];
            this.isBusinessClosed = _data["isBusinessClosed"];
            this.audioFileUI = _data["audioFileUI"] ? AudioFileUI.fromJS(_data["audioFileUI"]) : <any>undefined;
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.holidayName = _data["holidayName"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): HolidayUI {
        data = typeof data === 'object' ? data : {};
        let result = new HolidayUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holidayId"] = this.holidayId;
        data["isBusinessClosed"] = this.isBusinessClosed;
        data["audioFileUI"] = this.audioFileUI ? this.audioFileUI.toJSON() : <any>undefined;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["holidayName"] = this.holidayName;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface IHolidayUI {
    holidayId: string;
    isBusinessClosed: boolean;
    audioFileUI?: AudioFileUI | undefined;
    fromDate: Date;
    toDate: Date;
    holidayName?: string | undefined;
    isSubscribed: boolean;
}

export class MenuUI implements IMenuUI {
    menuId!: string;
    menuName?: string | undefined;
    description?: string | undefined;
    timeout?: number | undefined;
    dtfAudioIds?: string | undefined;
    configuration?: string | undefined;

    constructor(data?: IMenuUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.menuId = _data["menuId"];
            this.menuName = _data["menuName"];
            this.description = _data["description"];
            this.timeout = _data["timeout"];
            this.dtfAudioIds = _data["dtfAudioIds"];
            this.configuration = _data["configuration"];
        }
    }

    static fromJS(data: any): MenuUI {
        data = typeof data === 'object' ? data : {};
        let result = new MenuUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["menuName"] = this.menuName;
        data["description"] = this.description;
        data["timeout"] = this.timeout;
        data["dtfAudioIds"] = this.dtfAudioIds;
        data["configuration"] = this.configuration;
        return data;
    }
}

export interface IMenuUI {
    menuId: string;
    menuName?: string | undefined;
    description?: string | undefined;
    timeout?: number | undefined;
    dtfAudioIds?: string | undefined;
    configuration?: string | undefined;
}

export class PhoneNumberUI implements IPhoneNumberUI {
    action?: string | undefined;
    businessHours?: string | undefined;
    holidays?: string | undefined;
    phoneNumberDigits?: string | undefined;
    phoneNumberId!: string;
    ringTimeout?: number | undefined;
    marketingMessages?: string[] | undefined;
    timeZone?: string | undefined;
    voicemailAudioId?: string | undefined;
    voicemailEmail?: string | undefined;

    constructor(data?: IPhoneNumberUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.businessHours = _data["businessHours"];
            this.holidays = _data["holidays"];
            this.phoneNumberDigits = _data["phoneNumberDigits"];
            this.phoneNumberId = _data["phoneNumberId"];
            this.ringTimeout = _data["ringTimeout"];
            if (Array.isArray(_data["marketingMessages"])) {
                this.marketingMessages = [] as any;
                for (let item of _data["marketingMessages"])
                    this.marketingMessages!.push(item);
            }
            this.timeZone = _data["timeZone"];
            this.voicemailAudioId = _data["voicemailAudioId"];
            this.voicemailEmail = _data["voicemailEmail"];
        }
    }

    static fromJS(data: any): PhoneNumberUI {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumberUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["businessHours"] = this.businessHours;
        data["holidays"] = this.holidays;
        data["phoneNumberDigits"] = this.phoneNumberDigits;
        data["phoneNumberId"] = this.phoneNumberId;
        data["ringTimeout"] = this.ringTimeout;
        if (Array.isArray(this.marketingMessages)) {
            data["marketingMessages"] = [];
            for (let item of this.marketingMessages)
                data["marketingMessages"].push(item);
        }
        data["timeZone"] = this.timeZone;
        data["voicemailAudioId"] = this.voicemailAudioId;
        data["voicemailEmail"] = this.voicemailEmail;
        return data;
    }
}

export interface IPhoneNumberUI {
    action?: string | undefined;
    businessHours?: string | undefined;
    holidays?: string | undefined;
    phoneNumberDigits?: string | undefined;
    phoneNumberId: string;
    ringTimeout?: number | undefined;
    marketingMessages?: string[] | undefined;
    timeZone?: string | undefined;
    voicemailAudioId?: string | undefined;
    voicemailEmail?: string | undefined;
}

export class Recording implements IRecording {
    recordingId!: string;
    toPhoneNumberDigits?: string | undefined;
    fromPhoneNumberDigits?: string | undefined;
    recordingUrl?: string | undefined;
    callSessionId!: string;
    createdDateTime!: Date;

    constructor(data?: IRecording) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recordingId = _data["recordingId"];
            this.toPhoneNumberDigits = _data["toPhoneNumberDigits"];
            this.fromPhoneNumberDigits = _data["fromPhoneNumberDigits"];
            this.recordingUrl = _data["recordingUrl"];
            this.callSessionId = _data["callSessionId"];
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Recording {
        data = typeof data === 'object' ? data : {};
        let result = new Recording();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordingId"] = this.recordingId;
        data["toPhoneNumberDigits"] = this.toPhoneNumberDigits;
        data["fromPhoneNumberDigits"] = this.fromPhoneNumberDigits;
        data["recordingUrl"] = this.recordingUrl;
        data["callSessionId"] = this.callSessionId;
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecording {
    recordingId: string;
    toPhoneNumberDigits?: string | undefined;
    fromPhoneNumberDigits?: string | undefined;
    recordingUrl?: string | undefined;
    callSessionId: string;
    createdDateTime: Date;
}

export class RuleUI implements IRuleUI {
    ruleId!: string;
    ruleName?: string | undefined;
    ruleItems?: string | undefined;
    defaultRuleAction?: string | undefined;

    constructor(data?: IRuleUI) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleId = _data["ruleId"];
            this.ruleName = _data["ruleName"];
            this.ruleItems = _data["ruleItems"];
            this.defaultRuleAction = _data["defaultRuleAction"];
        }
    }

    static fromJS(data: any): RuleUI {
        data = typeof data === 'object' ? data : {};
        let result = new RuleUI();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleId"] = this.ruleId;
        data["ruleName"] = this.ruleName;
        data["ruleItems"] = this.ruleItems;
        data["defaultRuleAction"] = this.defaultRuleAction;
        return data;
    }
}

export interface IRuleUI {
    ruleId: string;
    ruleName?: string | undefined;
    ruleItems?: string | undefined;
    defaultRuleAction?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
